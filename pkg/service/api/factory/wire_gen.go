// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package factory

import (
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/logger"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/api"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/api/delivery/http"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/api/delivery/ws"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/api/repository"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/api/usecase"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/auth"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/game"
	"github.com/go-park-mail-ru/2019_2_LeMMaS/pkg/service/user"
	"github.com/labstack/echo"
	"google.golang.org/grpc"
	"os"
)

// Injectors from wire.go:

func NewMiddleware() (http.Middleware, error) {
	echo := NewEcho()
	metrics, err := api.NewMetrics()
	if err != nil {
		return http.Middleware{}, err
	}
	logger, err := NewLogger()
	if err != nil {
		return http.Middleware{}, err
	}
	middleware := http.NewMiddleware(echo, metrics, logger)
	return middleware, nil
}

func NewMetricsHandler() (*http.MetricsHandler, error) {
	echo := NewEcho()
	metricsHandler := http.NewMetricsHandler(echo)
	return metricsHandler, nil
}

func NewAccessHandler() (*http.AccessHandler, error) {
	echo := NewEcho()
	csrfUsecase := usecase.NewCSRFUsecase()
	logger, err := NewLogger()
	if err != nil {
		return nil, err
	}
	accessHandler := http.NewAccessHandler(echo, csrfUsecase, logger)
	return accessHandler, nil
}

func NewGameHandler() (*ws.GameHandler, error) {
	echo := NewEcho()
	gameClient, err := newGameClient()
	if err != nil {
		return nil, err
	}
	logger, err := NewLogger()
	if err != nil {
		return nil, err
	}
	gameUsecase := usecase.NewGameUsecase(gameClient, logger)
	authClient, err := newAuthClient()
	if err != nil {
		return nil, err
	}
	authUsecase := usecase.NewAuthUsecase(authClient, logger)
	gameHandler := ws.NewGameHandler(echo, gameUsecase, authUsecase, logger)
	return gameHandler, nil
}

func NewUserHandler() (*http.UserHandler, error) {
	echo := NewEcho()
	userClient, err := newUserClient()
	if err != nil {
		return nil, err
	}
	logger, err := NewLogger()
	if err != nil {
		return nil, err
	}
	fileRepository := repository.NewS3Repository(logger)
	userUsecase := usecase.NewUserUsecase(userClient, fileRepository, logger)
	authClient, err := newAuthClient()
	if err != nil {
		return nil, err
	}
	authUsecase := usecase.NewAuthUsecase(authClient, logger)
	userHandler := http.NewUserHandler(echo, userUsecase, authUsecase, logger)
	return userHandler, nil
}

// wire.go:

var echoInstance *echo.Echo = nil

func NewEcho() *echo.Echo {
	if echoInstance == nil {
		echoInstance = echo.New()
	}
	return echoInstance
}

var loggerInstance *logger.Logger = nil

func NewLogger() (logger.Logger, error) {
	if loggerInstance == nil {
		echoLogger := logger.NewEchoLogger(NewEcho())
		sentryLogger, err := logger.NewSentryLogger()
		if err != nil {
			return nil, err
		}
		combinedLogger := logger.NewCombinedLogger(echoLogger, sentryLogger)
		loggerInstance = &combinedLogger
	}
	return *loggerInstance, nil
}

func newAuthClient() (auth.AuthClient, error) {
	conn, err := newGRPC("auth:" + os.Getenv("PORT"))
	return auth.NewAuthClient(conn), err
}

func newUserClient() (user.UserClient, error) {
	conn, err := newGRPC("user:" + os.Getenv("PORT"))
	return user.NewUserClient(conn), err
}

func newGameClient() (game.GameClient, error) {
	conn, err := newGRPC("game:" + os.Getenv("PORT"))
	return game.NewGameClient(conn), err
}

func newGRPC(url string) (*grpc.ClientConn, error) {
	conn, err := grpc.Dial(url, grpc.WithInsecure())
	if err != nil {
		return nil, err
	}
	return conn, nil
}
